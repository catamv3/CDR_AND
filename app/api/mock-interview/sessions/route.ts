import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/utils/supabase/server";

/**
 * Create a new mock interview session
 * POST /api/mock-interview/sessions
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();

    // Get current user
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await request.json();
    const { sessionId, sessionType = "mock_interview" } = body;

    // Enforce unique session codes across all mock interviews
    const { data: existing } = await supabase
      .from('study_pod_sessions')
      .select('id, host_user_id')
      .contains('metadata', { session_id: sessionId })
      .maybeSingle();

    if (existing) {
      return NextResponse.json(
        { error: 'Session ID already in use. Please generate a new one.' },
        { status: 409 }
      );
    }

    // Try to associate with any pod the user belongs to (if schema requires pod_id NOT NULL)
    let hostPodId: string | null = null;
    try {
      const { data: membership } = await supabase
        .from('study_pod_members')
        .select('pod_id')
        .eq('user_id', user.id)
        .eq('status', 'active')
        .limit(1)
        .maybeSingle();
      hostPodId = membership?.pod_id || null;
    } catch (e) {
      // Ignore â€” we'll attempt insert without a pod_id if allowed
    }

    // Helper to try different shapes depending on schema
    const nowIso = new Date().toISOString();
    const baseMeta = {
      session_id: sessionId,
      is_mock_interview: true,
      max_participants: 2,
    } as const;

    const attemptInserts = async () => {
      // Attempt A: newer schema with scheduled_at/started_at/status/title
      let { data, error } = await supabase
        .from('study_pod_sessions')
        .insert({
          ...(hostPodId ? { pod_id: hostPodId } : {}),
          title: 'Mock Interview',
          description: null,
          session_type: sessionType,
          scheduled_at: nowIso,
          started_at: nowIso,
          status: 'in_progress',
          host_user_id: user.id,
          metadata: baseMeta,
        })
        .select()
        .single();
      if (!error) return { data, error } as const;

      // Attempt B: older schema with start_time/end_time
      ({ data, error } = await supabase
        .from('study_pod_sessions')
        .insert({
          ...(hostPodId ? { pod_id: hostPodId } : {}),
          session_type: sessionType,
          start_time: nowIso,
          host_user_id: user.id,
          metadata: baseMeta,
        })
        .select()
        .single());
      if (!error) return { data, error } as const;

      // Attempt C: minimal insert (if other columns are autogenerated/defaulted)
      ({ data, error } = await supabase
        .from('study_pod_sessions')
        .insert({
          ...(hostPodId ? { pod_id: hostPodId } : {}),
          session_type: sessionType,
          host_user_id: user.id,
          metadata: baseMeta,
        })
        .select()
        .single());
      return { data, error } as const;
    };

    let { data: session, error: sessionError } = await attemptInserts();

    // If insert failed and we have no pod_id, try creating a private pod as a holder
    if (sessionError && !hostPodId) {
      try {
        const { data: pod, error: podError } = await supabase
          .from('study_pods')
          .insert({
            created_by: user.id,
            name: 'Mock Interview Pod',
            description: 'Auto-created to host mock interview sessions',
            subject: 'Mock Interviews',
            skill_level: 'Mixed',
            max_members: 2,
            is_public: false,
            requires_approval: false,
            meeting_schedule: [],
            topics: [],
            status: 'active',
            metadata: { kind: 'mock_interview_pod', created_by_feature: 'mock_interview' },
            color_scheme: 'indigo',
            target_problems_count: 0,
          })
          .select()
          .single();

        if (!podError && pod?.id) {
          hostPodId = pod.id;
          // Try session creation again with the new pod
          ({ data: session, error: sessionError } = await attemptInserts());
        } else {
          console.error('Failed to auto-create mock interview pod:', podError);
        }
      } catch (e) {
        console.error('Unexpected error while creating pod:', e);
      }
    }

    if (sessionError) {
      console.error("Error creating session:", sessionError);
      console.error('Error creating session (detailed):', sessionError);
      return NextResponse.json({ error: sessionError?.message || 'Failed to create session', details: sessionError }, { status: 500 });
    }

    // Add host as participant
    const { error: attendanceError } = await supabase
      .from("session_attendance")
      .insert({
        session_id: session.id,
        user_id: user.id,
        joined_at: new Date().toISOString(),
      });

    if (attendanceError) {
      console.error("Error adding host attendance:", attendanceError);
    }

    return NextResponse.json({
      success: true,
      session: {
        id: session.id,
        sessionId: sessionId,
        hostId: user.id,
        createdAt: session.started_at || session.scheduled_at,
      },
    });
  } catch (error) {
    console.error("Error in POST /api/mock-interview/sessions:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

/**
 * Get session information
 * GET /api/mock-interview/sessions?sessionId=xxx
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();

    // Get current user
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const searchParams = request.nextUrl.searchParams;
    const sessionId = searchParams.get("sessionId");

    if (!sessionId) {
      return NextResponse.json(
        { error: "Session ID is required" },
        { status: 400 }
      );
    }

    // Find session by custom session_id in metadata
    // Note: RLS restricts visibility to mock_interview via policy; we avoid
    // adding extra filters to reduce chances of 404 due to schema differences.
    const { data: session, error: sessionError } = await supabase
      .from("study_pod_sessions")
      .select(
        `
        *,
        host:host_user_id (
          user_id,
          full_name,
          username,
          avatar_url
        )
      `
      )
      .contains("metadata", { session_id: sessionId })
      .single();

    if (sessionError || !session) {
      return NextResponse.json({ error: "Session not found" }, { status: 404 });
    }

    // Get participants
    const { data: participants, error: participantsError } = await supabase
      .from("session_attendance")
      .select(
        `
        *,
        user:user_id (
          user_id,
          full_name,
          username,
          avatar_url
        )
      `
      )
      .eq("session_id", session.id);

    if (participantsError) {
      console.error("Error fetching participants:", participantsError);
    }

    return NextResponse.json({
      session: {
        id: session.id,
        sessionId: session.metadata.session_id,
        hostId: session.host_user_id,
        host: session.host,
        metadata: session.metadata,
        startTime: session.started_at || session.scheduled_at,
        endTime: session.ended_at,
        participants: participants || [],
      },
    });
  } catch (error) {
    console.error("Error in GET /api/mock-interview/sessions:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

/**
 * Update session (end session, update recording URL, etc.)
 * PATCH /api/mock-interview/sessions
 */
export async function PATCH(request: NextRequest) {
  try {
    const supabase = await createClient();

    // Get current user
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await request.json();
    const { sessionId, action, recordingUrl } = body;

    if (!sessionId) {
      return NextResponse.json(
        { error: "Session ID is required" },
        { status: 400 }
      );
    }

    // Find session
    const { data: session, error: sessionError } = await supabase
      .from("study_pod_sessions")
      .select("*")
      .contains("metadata", { session_id: sessionId })
      .single();

    if (sessionError || !session) {
      return NextResponse.json({ error: "Session not found" }, { status: 404 });
    }

    // Verify user is host
    if (session.host_user_id !== user.id) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    let updateData: any = {};

    if (action === "host_ready") {
      const newMeta = { ...(session.metadata || {}), host_ready: true };
      const { data: updated, error: metaErr } = await supabase
        .from("study_pod_sessions")
        .update({ metadata: newMeta })
        .eq("id", session.id)
        .select()
        .single();

      if (metaErr) {
        console.error("Error setting host_ready:", metaErr);
        return NextResponse.json({ error: "Failed to update host status" }, { status: 500 });
      }
      return NextResponse.json({ success: true, session: updated });
    } else if (action === "end") {
      updateData = {
        ended_at: new Date().toISOString(),
        status: "completed",
      };

      // Update attendance record
      const { error: attendanceError } = await supabase
        .from("session_attendance")
        .update({
          left_at: new Date().toISOString(),
        })
        .eq("session_id", session.id)
        .eq("user_id", user.id);

      if (attendanceError) {
        console.error("Error updating attendance:", attendanceError);
      }
    } else if (action === "save_recording" && recordingUrl) {
      updateData = {
        recording_url: recordingUrl,
      };
    }

    const { data: updatedSession, error: updateError } = await supabase
      .from("study_pod_sessions")
      .update(updateData)
      .eq("id", session.id)
      .select()
      .single();

    if (updateError) {
      console.error("Error updating session:", updateError);
      return NextResponse.json(
        { error: "Failed to update session" },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      session: updatedSession,
    });
  } catch (error) {
    console.error("Error in PATCH /api/mock-interview/sessions:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
